procedure Gravity()
    if NOT isGrounded then
        movement = movement - gravity * Time.deltaTime
    endif
endprocedure

procedure SetPlayerDimensions(height, radius)
    previousHeight = playerCollider.height
    playerCollider.height = height
    player.transform.position = player.transform.position - Vector3(0, (previousHeight - height)/2, 0)
endprocedure

procedure Crouch()
    if lastMovementState != movementState then
        if movementState == PlayerMovementState.crouching OR movementState == PlayerMovementState.sliding then
            SetPlayerDimensions(crouchingHeight, playerRadius)
        else
            SetPlayerDimensions(standingHeight, playerRadius)
        endif
    endif
endprocedure

function CrouchControlState()
    holdCrouch = playerInputs.Player.HoldCrouch.inProgress
    if playerInputs.Player.toggleCrouch.triggered then
        if toggleCrouch == true then
            toggleCrouch = false
        else
            toggleCrouch = true
        endif
    endif
    if holdCrouch == true then
        lastHoldCrouchState = true
        return true
    else
        if lastHoldCrouchState == true then
            toggleCrouch = false
        endif
        lastHoldCrouchState = false
        return toggleCrouch
    endif
endfunction

procedure Movement()
    acceleration = baseMovementAcceleration
    target = player.rotation * inputDirection
    alignment = Vector3.Dot(groundVelocity.normalized, target.normalized)
    if groundVelocity.magnitude > maxSpeed then
        acceleration = acceleration * groundVelocity.magnitude / maxSpeed
    endif
    direction = target * maxSpeed - groundVelocity
    direction = Vector3.ProjectOnPlane(direction, groundNormal)
    direction = direction.normalized * acceleration
    direction = direction - direction * frictionMultiplier
    movement = movement + direction * Time.deltaTime
endprocedure

procedure Jump()
    direction = Vector3.up * jumpForce
    if velocity.y < 0 then
        direction.y = direction.y - velocity.y
    endif
    if isGrounded == true then
        movement = movement + direction
    else if airJumpsLeft > 0 then
        movement = movement + direction
        airJumpsLeft = airJumpsLeft - 1
    endif
endprocedure

procedure Boost()
    movementState = movementState.boosting
    inputDirection = playerInputs.Player.Movement.ReadValue()
    boostMovement = player.rotation * inputDirection * groundVelocity.magnitude * (boostMultiplier - 1)
    movement = movement + boostMovement
endprocedure